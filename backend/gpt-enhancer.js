require("dotenv").config();
const OpenAI = require("openai");

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// --- Main GPT Interaction Function ---
// Handles sending the raw Playwright script to OpenAI's GPT model
// and processes the enhanced script received in return.
async function askGPT(rawScript) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo", // updated model for better performance
      temperature: 0.4,
      messages: [
        {
          role: "system",
          content: `You are an expert Playwright Test engineer. You will receive a raw script generated by Playwright Codegen. Your job is to transform it into a modular, well-commented test suite using Playwright Test Runner ‚Äî but without altering functional behavior or test intent.

‚ö†Ô∏è IMPORTANT GUIDELINE FOR END-TO-END FLOWS:
If the provided raw script represents a single, continuous end-to-end user journey (e.g., login, perform actions, checkout, logout), it MUST be contained within a SINGLE test() block. Do NOT break a continuous user flow into multiple test() blocks, as this alters the original execution intent (which is to run as one uninterrupted sequence in a single browser context).

‚úÖ DO:
1. Use Playwright Test Runner: import { test, expect } from '@playwright/test'
2. If the script contains *multiple distinct and disconnected* test scenarios, group them using test.describe() with clear titles. Otherwise, for a single E2E flow, test.describe() can wrap the single test for better organization.
3. Use test.beforeEach() for repeated setup like page.goto(), but only if there are multiple *independent* test() blocks within a describe block. For a single E2E test, page.goto() should be the first step *inside* that test.
4. Ensure each test() block:
   - Has a descriptive title reflecting the scenario.
   - Includes comments describing each step.
5. Preserve the original script‚Äôs logic and step order.
6. Use page.goto(url, { waitUntil: 'networkidle' }) when applicable.
7. Use page.waitForEvent('popup') or context.waitForEvent('page') for new tabs/popups.
8. Use Playwright assertions like expect(locator).toBeVisible(), not expect(await ...).
9. Avoid using waitForTimeout() or hardcoded delays.
10. Inline single-use locators unless reused across steps.
11. Do not click error messages; just assert their visibility or content.

üö´ DO NOT:
- Modify, rename, simplify, or rephrase any locators or selectors (e.g., page.locator(...), getByRole, text selectors, etc.).
- Infer, guess, or fabricate test steps not present in the input.
- Add your own assertions, navigations, or interactions unless they are directly present in the raw script.
- Break a continuous end-to-end user flow into separate test() blocks. This is crucial for maintaining the original execution flow.

üìå Maintain locator and assertion integrity. This means: all selectors, test data, and element actions must be identical to the input.

üì§ Return raw JavaScript code only ‚Äî no Markdown, explanations, or formatting.

Your output must be 100% faithful to the user input except for the structural modularization and comments, and ensuring continuous E2E flows remain single tests.`
        },
        {
          role: "user",
          content: `Convert the following Playwright script into structured test cases:\n\n${rawScript}`
        }
      ]
    });

    const enhancedScript = response.choices[0].message.content.trim();
    // Verify that essential locators from the original script are present in the enhanced script.
    verifyLocatorIntegrity(rawScript, enhancedScript);
    // Apply post-processing rules to clean up and optimize the script.
    return postProcessScript(enhancedScript);
  } catch (error) {
    console.error("üî• GPT Query Failed:", error.message);
    throw error;
  }
}

// --- Script Post-Processing Function ---
// Applies a series of regex replacements to clean up, optimize, and standardize
// the Playwright script generated by GPT.
function postProcessScript(script) {
  // Ensure the Playwright import statement is at the very top and unique.
  const playwrightImport = "import { test, expect } from '@playwright/test';";
  // Remove any duplicate or misplaced import statements if GPT generates them.
  script = script.replace(new RegExp(`${playwrightImport}\\s*`, 'g'), '').trim();
  // Add the import statement to the very top.
  script = playwrightImport + '\n\n' + script;


  // Fix improper usage: expect(await ...) ‚Üí expect(...)
  // Removes 'await' from inside 'expect' calls as Playwright handles async assertions.
  script = script.replace(/expect\s*\(\s*await\s+(.*?)\)/g, 'expect($1)');

  // Convert `.isVisible().toBe(true)` to `await expect(locator).toBeVisible()`
  // Standardizes visibility assertions to Playwright's recommended form.
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.toBe\(true\);/g,
    'await expect($1).toBeVisible();'
  );

  // Convert `.isVisible().not.toBe(true)` to `await expect(locator).not.toBeVisible()`
  // Standardizes negative visibility assertions.
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.not\.toBe\(true\);/g,
    'await expect($1).not.toBeVisible();'
  );

  // --- Handle click & fill/check in one line ---
  // This regex looks for:
  // 1. `await`
  // 2. Captures the full Playwright locator expression (e.g., `page.locator('[data-test="username"]')`)
  //    in a named group `locator`. This group is critical for the backreference.
  // 3. `.click();`
  // 4. Optional whitespace and newlines (`\s*(?:\r?\n\s*)?`) that might be between the click and fill.
  // 5. A positive lookahead `(?=...)` ensures that the *exact same locator* is followed by
  //    `.fill(` or `.check(`.
  // If the pattern matches, the entire `await ... .click();` line (including trailing newline)
  // is replaced with an empty string, effectively removing it.
  script = script.replace(
    /(await\s+(?<locator>(?:page\.(?:locator|getByRole|getByText|getByLabel|getByPlaceholder|getByAltText|getByTitle|getByTestId)\((?:'[^']*?'|"[^"]*?"|`[^`]*?`)(?:,\s*\{[^}]*?\})?\)))\.click\(\);\s*(?:\r?\n\s*)?)(?=await\s+\k<locator>\.(?:fill|check)\()/g,
    ''
  );

  // Remove empty beforeEach blocks (useful if GPT mistakenly creates one)
  // Cleans up extraneous `beforeEach` hooks that serve no purpose.
  script = script.replace(/test\.beforeEach\([^)]*\)\s*=>\s*\{\s*\}\);?/g, "");

  // Trim leading/trailing whitespace from the final script.
  return script.trim();
}

// --- Locator Extraction Function ---
// Extracts all Playwright locator strings from a given script using regex.
function extractLocators(script) {
  const locators = new Set();
  // Improved regex to capture page.locator, getByRole, etc.
  const regex = /(page\.(?:locator|getByRole|getByText|getByLabel|getByPlaceholder|getByAltText|getByTitle|getByTestId)\(['"`].+?['"`](?:,\s*\{[^}]*?\})?\))/g;
  let match;
  while ((match = regex.exec(script)) !== null) {
    locators.add(match[1]);
  }
  return locators;
}

// --- Locator Integrity Verification Function ---
// Compares locators from the original script against the transformed script
// to ensure no locators were inadvertently modified or removed during the process.
function verifyLocatorIntegrity(originalScript, transformedScript) {
  const originalLocators = extractLocators(originalScript);
  const transformedLocators = extractLocators(transformedScript);

  const missing = [...originalLocators].filter(l => !transformedLocators.has(l));
  if (missing.length > 0) {
    console.warn("‚ö†Ô∏è Warning: Some locators were modified or removed by GPT:\n", missing.join('\n'));
  }
}

// --- Module Exports ---
// Exports the main function for external use.
module.exports = { askGPT };