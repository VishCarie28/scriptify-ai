require("dotenv").config();
const OpenAI = require("openai");

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function askGPT(rawScript) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo", // updated model for better performance
      temperature: 0.4,
      messages: [
        {
          role: "system",
          content: `You are an expert Playwright Test engineer. You will receive a raw script generated by Playwright Codegen. Your job is to transform it into a modular, well-commented test suite using Playwright Test Runner ‚Äî but without altering functional behavior or test intent.

‚ö†Ô∏è IMPORTANT GUIDELINE FOR END-TO-END FLOWS:
If the provided raw script represents a single, continuous end-to-end user journey (e.g., login, perform actions, checkout, logout), it MUST be contained within a SINGLE test() block. Do NOT break a continuous user flow into multiple test() blocks, as this alters the original execution intent (which is to run as one uninterrupted sequence in a single browser context).

‚úÖ DO:
1. Use Playwright Test Runner: import { test, expect } from '@playwright/test'
2. If the script contains *multiple distinct and disconnected* test scenarios, group them using test.describe() with clear titles. Otherwise, for a single E2E flow, test.describe() can wrap the single test for better organization.
3. Use test.beforeEach() for repeated setup like page.goto(), but only if there are multiple *independent* test() blocks within a describe block. For a single E2E test, page.goto() should be the first step *inside* that test.
4. Ensure each test() block:
   - Has a descriptive title reflecting the scenario.
   - Includes comments describing each step.
5. Preserve the original script‚Äôs logic and step order.
6. Use page.goto(url, { waitUntil: 'networkidle' }) when applicable.
7. Use page.waitForEvent('popup') or context.waitForEvent('page') for new tabs/popups.
8. Use Playwright assertions like expect(locator).toBeVisible(), not expect(await ...).
9. Avoid using waitForTimeout() or hardcoded delays.
10. Inline single-use locators unless reused across steps.
11. Do not click error messages; just assert their visibility or content.

üö´ DO NOT:
- Modify, rename, simplify, or rephrase any locators or selectors (e.g., page.locator(...), getByRole, text selectors, etc.).
- Infer, guess, or fabricate test steps not present in the input.
- Add your own assertions, navigations, or interactions unless they are directly present in the raw script.
- Break a continuous end-to-end user flow into separate test() blocks. This is crucial for maintaining the original execution flow.

üìå Maintain locator and assertion integrity. This means: all selectors, test data, and element actions must be identical to the input.

üì§ Return raw JavaScript code only ‚Äî no Markdown, explanations, or formatting.

Your output must be 100% faithful to the user input except for the structural modularization and comments, and ensuring continuous E2E flows remain single tests.`
        },
        {
          role: "user",
          content: `Convert the following Playwright script into structured test cases:\n\n${rawScript}`
        }
      ]
    });

    const enhancedScript = response.choices[0].message.content.trim();
    verifyLocatorIntegrity(rawScript, enhancedScript);
    return postProcessScript(enhancedScript);
  } catch (error) {
    console.error("üî• GPT Query Failed:", error.message);
    throw error;
  }
}

function postProcessScript(script) {
  // Ensure the Playwright import statement is at the very top
  const playwrightImport = "import { test, expect } from '@playwright/test';";
  if (!script.includes(playwrightImport)) {
    script = playwrightImport + '\n\n' + script;
  }
  // Remove any duplicate or misplaced import statements if GPT generates them
  script = script.replace(new RegExp(`${playwrightImport}\\s*`, 'g'), '').trim();
  script = playwrightImport + '\n\n' + script;


  // Fix improper usage: expect(await ...) ‚Üí expect(...)
  script = script.replace(/expect\s*\(\s*await\s+(.*?)\)/g, 'expect($1)');

  // Convert `.isVisible().toBe(true)` to `await expect(locator).toBeVisible()`
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.toBe\(true\);/g,
    'await expect($1).toBeVisible();'
  );

  // Convert `.isVisible().not.toBe(true)` to `await expect(locator).not.toBe\(true\)`
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.not\.toBe\(true\);/g,
    'await expect($1).not.toBeVisible();'
  );

  // Remove .click() if it's immediately followed by fill/check
  script = script.replace(
    /\.click\(\);\s*(?=(await\s+)?\w+\.(fill|check)\()/g,
    ''
  );

  // Remove empty beforeEach blocks (useful if GPT mistakenly creates one)
  script = script.replace(/test\.beforeEach\([^)]*\)\s*=>\s*\{\s*\}\);?/g, "");

  return script.trim();
}

function extractLocators(script) {
  const locators = new Set();
  // Improved regex to capture page.locator, getByRole, etc.
  const regex = /(page\.(?:locator|getByRole|getByText|getByLabel|getByPlaceholder|getByAltText|getByTitle|getByTestId)\(['"`].+?['"`](?:,\s*\{[^}]*?\})?\))/g;
  let match;
  while ((match = regex.exec(script)) !== null) {
    locators.add(match[1]);
  }
  return locators;
}

function verifyLocatorIntegrity(originalScript, transformedScript) {
  const originalLocators = extractLocators(originalScript);
  const transformedLocators = extractLocators(transformedScript);

  const missing = [...originalLocators].filter(l => !transformedLocators.has(l));
  if (missing.length > 0) {
    console.warn("‚ö†Ô∏è Warning: Some locators were modified or removed by GPT:\n", missing.join('\n'));
  }
}

module.exports = { askGPT };
