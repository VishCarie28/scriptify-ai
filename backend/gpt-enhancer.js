require("dotenv").config();
const OpenAI = require("openai");

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function askGPT(rawScript) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo", // updated model for better performance
      temperature: 0.4,
      messages: [
        {
          role: "system",
          content: `You are an expert Playwright Test engineer. You will receive a raw script generated by Playwright Codegen. Your job is to transform it into a modular, well-commented test suite using Playwright Test Runner ‚Äî but without altering functional behavior or test intent.

‚ö†Ô∏è DO NOT:
- Modify, rename, simplify, or rephrase any locators or selectors (e.g., page.locator(...), getByRole, text selectors, etc.).
- Infer, guess, or fabricate test steps not present in the input.
- Add your own assertions, navigations, or interactions unless they are directly present in the raw script.

‚úÖ DO:
1. Use Playwright Test Runner: import { test, expect } from '@playwright/test'
2. Group related tests using test.describe() with clear titles.
3. Use test.beforeEach() for repeated setup like page.goto().
4. Ensure each test() block:
   - Is self-contained
   - Has a descriptive title
   - Includes comments describing each step
5. Preserve the original script‚Äôs logic and step order unless refactoring for modularity.
6. Use page.goto(url, { waitUntil: 'networkidle' }) when applicable.
7. Use page.waitForEvent('popup') or context.waitForEvent('page') for new tabs/popups.
8. Use Playwright assertions like expect(locator).toBeVisible(), not expect(await ...).
9. Avoid using waitForTimeout() or hardcoded delays.
10. Inline single-use locators unless reused across steps.
11. Do not click error messages; just assert their visibility or content.

üìå Maintain locator and assertion integrity. This means: all selectors, test data, and element actions must be identical to the input.

üì§ Return raw JavaScript code only ‚Äî no Markdown, explanations, or formatting.

Your output must be 100% faithful to the user input except for the structural modularization and comments.`
        },
        {
          role: "user",
          content: `Convert the following Playwright script into structured test cases:\n\n${rawScript}`
        }
      ]
    });

    const enhancedScript = response.choices[0].message.content.trim();
    verifyLocatorIntegrity(rawScript, enhancedScript);
    return postProcessScript(enhancedScript);
  } catch (error) {
    console.error("üî• GPT Query Failed:", error.message);
    throw error;
  }
}

function postProcessScript(script) {
  const gotoMatch = script.match(/await\s+page\.goto\(['"](.*?)['"]/);
  const baseUrl = gotoMatch?.[1];

  if (baseUrl) {
    script = script.replace(
      new RegExp(`\\s*await\\s+page\\.goto\\(['"]${baseUrl}['"](,\\s*\\{[^}]*\\})?\\);?`, "g"),
      ""
    );

    const describeBlock = /test\.describe\((['"`].*?['"`]),\s*\(\)\s*=>\s*\{/;
    if (describeBlock.test(script)) {
      script = script.replace(describeBlock, (match) => {
        return `${match}\n  test.beforeEach(async ({ page }) => {\n    await page.goto('${baseUrl}', { waitUntil: 'networkidle' });\n  });`;
      });
    } else {
      script = script.replace(
        /test\((['"`].*?['"`]),\s*async\s*\(\{\s*page[^}]*\}\)\s*=>\s*\{/g,
        (match, name) => `test(${name}, async ({ page, context }) => {\n  await page.goto('${baseUrl}', { waitUntil: 'networkidle' });`
      );
    }
  }

  // Fix improper usage: expect(await ...) ‚Üí expect(...)
  script = script.replace(/expect\s*\(\s*await\s+(.*?)\)/g, 'expect($1)');

  // Convert `.isVisible().toBe(true)` to `await expect(locator).toBeVisible()`
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.toBe\(true\);/g,
    'await expect($1).toBeVisible();'
  );

  // Convert `.isVisible().not.toBe(true)` to `await expect(locator).not.toBeVisible()`
  script = script.replace(
    /expect\(\s*(.+?)\.isVisible\(\)\s*\)\.not\.toBe\(true\);/g,
    'await expect($1).not.toBeVisible();'
  );

  // Remove .click() if it's immediately followed by fill/check
  script = script.replace(
    /\.click\(\);\s*(?=(await\s+)?\w+\.(fill|check)\()/g,
    ''
  );

  // Remove empty beforeEach blocks
  script = script.replace(/test\.beforeEach\([^)]*\)\s*=>\s*\{\s*\}\);?/g, "");

  return script.trim();
}

function extractLocators(script) {
  const locators = new Set();
  const regex = /page\.locator\((['"`].+?['"`])\)/g;
  let match;
  while ((match = regex.exec(script)) !== null) {
    locators.add(match[1]);
  }
  return locators;
}

function verifyLocatorIntegrity(originalScript, transformedScript) {
  const originalLocators = extractLocators(originalScript);
  const transformedLocators = extractLocators(transformedScript);

  const missing = [...originalLocators].filter(l => !transformedLocators.has(l));
  if (missing.length > 0) {
    console.warn("‚ö†Ô∏è Warning: Some locators were modified or removed by GPT:\n", missing);
  }
}

module.exports = { askGPT };
